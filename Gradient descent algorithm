# 导入库
from math import *
import time
import numpy as np
import matplotlib.pyplot as plt



# 原函数：二元2次非线性函数
def f(x, y):
    return (1.0 * x ** 2 + 2.0 * x * y + 1.0 * y ** 2 + 2.0 * x + 2.0 * y + 1)


x = np.arange(-50, 50, 10)
y = np.arange(-50, 50, 10)  # X,Y的范围

xd, yd = np.meshgrid(x, y)  # 空间的点序列转换成网格点

zd = f(xd, yd)  # 生成z轴的网格数据

figure = plt.figure()
ax1 = plt.axes(projection='3d')  # 创建三维坐标系

ax1.plot_surface(xd, yd, zd, rstride=1, cstride=1, cmap='rainbow')

# plt.show()-->显示图形用，下同



# 偏导函数：一阶对x的偏导函数
def fv1_x(x, y):
    return (2 * x + 2 * y + 2)  # 导函数


# 函数图形： 对x的偏导函数
x = np.arange(-50, 50, 10)
y = np.arange(-50, 50, 10)  # X,Y的范围

xd, yd = np.meshgrid(x, y)  # 空间的点序列转换成网格点

zd = fv1_x(xd, yd)  # 生成z轴的网格数据

figure = plt.figure()
ax1 = plt.axes(projection='3d')  # 创建三维坐标系

ax1.plot_surface(xd, yd, zd, rstride=1, cstride=1, cmap='rainbow')

# plt.show()


# 偏导函数：一阶对y的导函数
def fv1_y(x, y):
    return (2 * y + 2 * x + 2)  # 导函数


# 函数图形： 对y的偏导函数
x = np.arange(-50, 50, 10)
y = np.arange(-50, 50, 10)  # X,Y的范围

xd, yd = np.meshgrid(x, y)  # 空间的点序列转换成网格点

zd = fv1_y(xd, yd)  # 生成z轴的网格数据

figure = plt.figure()
ax1 = plt.axes(projection='3d')  # 创建三维坐标系

ax1.plot_surface(xd, yd, zd, rstride=1, cstride=1, cmap='rainbow')

# plt.show()


# 梯度下降法求最小值的算法h(函数)
def fmin_gradient_descent(f, fv1_x, fv1_y, init_x0, init_y0, learning_rate, max_loop):
    x_data = []
    y_data = []
    z_data = []
    x_k = init_x0
    x_k1 = init_x0
    y_k = init_y0
    y_k1 = init_y0

    for k in range(max_loop):
        # 计算梯度
        step_x = learning_rate * fv1_x(x_k, y_k)
        step_y = learning_rate * fv1_y(x_k, y_k)

        # 保存当前的迭代点
        x_data.append(x_k1)
        y_data.append(y_k1)
        z_data.append(f(x_k1, y_k1))

        x_k1 = x_k - step_x
        y_k1 = y_k - step_y

        # 为新一轮迭代做准备
        x_k = x_k1
        y_k = y_k1
        z_k = f(x_k, y_k)

    return ((x_k, y_k, z_k), (x_data, y_data, z_data))



# 梯度下降法算法使用
# learning_rate为学习率，此处为0.9，可以换为其他数值试验

result = fmin_gradient_descent(f, fv1_x, fv1_y, init_x0=10, init_y0=10, learning_rate=0.9, max_loop=100)
print(result[0])

iter_x = result[1][0]
item_y = result[1][1]
item_z = result[1][2]

fig = plt.figure()
ax1 = plt.axes(projection='3d')  # 创建三维坐标系
ax1.scatter3D(iter_x, item_y, item_z, c='r', marker='*')
